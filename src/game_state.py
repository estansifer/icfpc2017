import random
import numpy as np

#
# Gameboard consists of an undirected graph of edges.
#   Nodes are labelled by an integer SiteID.
#   Players are labelled by an integer, varying from 0 to n - 1 where n is the number of players.
#

class Node:
    # self.edges is a dictionary mapping the SiteID of neighboring sites to the instance of Edge
    # connecting them
    def __init__(self, nodeid):
        self.nodeid = nodeid
        self.ismine = False
        self.edges = {}

class Edge:
    def __init__(self, source, target, owner = -1):
        self.source = source
        self.target = target
        self.owner = owner


#
# Game -- holds the complete game state of the game at some point during play, including
#   any extra annotations that may have been added to help the solver.
#
# Game.from_json_setup(message)
#   Creates a new Game object using the message received from the server during setup.
# g.to_json_offline()
#   Returns an object suitable for serializing into json format which carries the complete
#   state of the game, for use in the offline mode.
# Game.from_json_offline(message)
#   Creates a Game object corresponding to the message received from the server, which had
#   been previously generated by the g.to_json_offline() function. In particular,
#       Game.from_json_offline(g.to_json_offline())
#   should yield a Game object with the same state as g.
#
# g.apply_moves(message)
#   Given a message received from the server describing moves made, update the game state.
# g.message_ready()
#   Give an appropriate ready message
# g.message_move(e) or g.message_pass()
#   Given an Edge instance which we should claim, return an appropriate message claiming
#   that edge to send to the server. The game state is not updated yet (it should be
#   updated by the response from the server).
#

class Game:
    # n -- number of players
    # me -- our player index, from 0 to n - 1 inclusive
    # self.nodes -- dictionary mapping SiteID to Node
    # self.edges -- list of all edges
    # self.mines -- list of SiteIDs of all Nodes which are mines
    def __init__(self, n, me):
        self.n = n
        self.me = me
        self.k = 0
        self.siteid2nodeid = {}
        self.nodeid2siteid = {}
        self.nodes = []
        self.edges = []
        self.mines = []
        self.set_settings({})

    def set_settings(self, settings):
        self.settings = settings
        self.futures = settings.get('futures', False)

    def add_node(self, siteid):
        nodeid = self.k
        self.siteid2nodeid[siteid] = nodeid
        self.nodeid2siteid[nodeid] = siteid
        self.k += 1
        node = Node(nodeid)
        self.nodes.append(node)
        return node

    def add_edge(self, source, target, owner = -1):
        edge = Edge(source, target, owner)
        self.edges.append(edge)
        self.nodes[source].edges[target] = edge
        self.nodes[target].edges[source] = edge

    def from_json_setup(message):
        g = Game(message['punters'], message['punter'])
        g.set_settings(message.get('settings', {}))
        m = message['map']

        for s in m['sites']:
            node = g.add_node(s['id'])
            if 'x' in s:
                node.x = s['x']
                node.y = s['y']

        for r in m['rivers']:
            a = g.siteid2nodeid[r['source']]
            b = g.siteid2nodeid[r['target']]
            g.add_edge(a, b)

        for mine in m['mines']:
            mine = g.siteid2nodeid[mine]
            g.nodes[mine].ismine = True
            g.mines.append(mine)

        g.floyd_warshall()
        return g

    def from_json_offline(message):
        g = Game(message['n'], message['me'])
        g.set_settings(message.get('settings', {}))
        m = message['map']

        for s in m['nodes']:
            g.add_node(s['siteid'])

        for e in m['edges']:
            g.add_edge(e['source'], e['target'], e['owner'])

        for mine in m['mines']:
            g.nodes[mine].ismine = True
            g.mines.append(mine)

        g.dists = m['dists']
        return g

    def to_json_offline(self):
        message = {}
        message['n'] = self.n
        message['me'] = self.me
        message['settings'] = self.settings
        m = {'nodes' : [], 'edges' : [], 'mines' : [], 'dists' : self.dists}
        message['map'] = m

        for node in self.nodes:
            m['nodes'].append({'siteid' : self.nodeid2siteid[node.nodeid]})

        for edge in self.edges:
            m['edges'].append({'source' : edge.source, 'target' : edge.target, 'owner' : edge.owner})

        for mine in self.mines:
            m['mines'].append(mine)

        return message

    def apply_moves(self, message):
        for m in message['moves']:
            if 'pass' in m:
                continue
            if 'claim' in m:
                c = m['claim']
                a = self.siteid2nodeid[c['source']]
                b = self.siteid2nodeid[c['target']]
                e = self.nodes[a].edges[b]
                e.owner = c['punter']

    def message_ready(self):
        message = {'ready' : self.me}
        if self.futures:
            message['futures'] = []
        return message

    def message_move(self, e):
        a = self.nodeid2siteid[e.source]
        b = self.nodeid2siteid[e.target]
        message = {'claim' : {'punter' : self.me, 'source' : a, 'target' : b}}
        return message

    def message_pass(self):
        return {'pass' : {'punter' : self.me}}

    def floyd_warshall(self):
        K = self.k
        large = K + 1
        self.dists = [[large for i in range(K)] for j in range(K)]
        for i in range(K):
            self.dists[i][i] = 0

        for e in self.edges:
            self.dists[e.source][e.target] = 1
            self.dists[e.target][e.source] = 1

        for k in range(K):
            for i in range(K):
                for j in range(K):
                    if self.dists[i][j] > self.dists[i][k] + self.dists[k][j]:
                        self.dists[i][j] = self.dists[i][k] + self.dists[k][j]

    def summary(self):
        lines = []
        lines.append(
                "{} nodes, {} edges, {} mines, {} punters, we are {}".format(
                    self.k, len(self.edges), len(self.mines), self.n, self.me))
        counts = [0] * self.n
        for edge in self.edges:
            if edge.owner >= 0:
                counts[edge.owner] += 1

        lines.append("#Edges owned: {}".format(counts))

        return lines

    def layout_initial(self):
        for node in self.nodes:
            node.x = random.random()
            node.y = random.random()

    def layout_relax(self, numsteps = 10):
        k = self.k

        x = np.zeros((k,))
        y = np.zeros((k,))
        connected = np.zeros((k, k), dtype = bool)
        diag = np.identity(k, dtype = bool)

        for i in range(k):
            x[i] = self.nodes[i].x
            y[i] = self.nodes[i].y
            for j in self.nodes[i].edges:
                connected[i, j] = True

        xlow = np.min(x)
        xhigh = np.max(x)
        ylow = np.min(y)
        yhigh = np.max(y)

        x = np.sqrt(k) * (x - xlow) / (xhigh - xlow)
        y = np.sqrt(k) * (y - ylow) / (yhigh - ylow)

        for i in range(numsteps):
            dx = np.zeros((k,))
            dy = np.zeros((k,))

            dd = (x[:, None] - x[None, :]) ** 2 + (y[:, None] - y[None, :]) ** 2
            dd[diag] = 1

            force_a = np.log(dd)
            # force_b = -1 / dd
            force_b = -1 / np.sqrt(dd)
            force_a[~connected] = 0
            force_b[connected] = 0
            force = force_a + force_b
            force[diag] = 0

            dx = np.sum(force * (x[None, :] - x[:, None]) / np.sqrt(dd), axis = 1)
            dy = np.sum(force * (y[None, :] - y[:, None]) / np.sqrt(dd), axis = 1)
            x += 0.1 * dx
            y += 0.1 * dy

        # Normalize positions to (0, 1)

        xlow = np.min(x)
        xhigh = np.max(x)
        ylow = np.min(y)
        yhigh = np.max(y)

        x = (x - xlow) / (xhigh - xlow)
        y = (y - ylow) / (yhigh - ylow)

        for i in range(k):
            self.nodes[i].x = x[i]
            self.nodes[i].y = y[i]

    def layout_normalize(self):
        xs = [node.x for node in self.nodes]
        ys = [node.y for node in self.nodes]

        xlow = min(xs)
        xhigh = max(xs)
        ylow = min(ys)
        yhigh = max(ys)

        for n in self.nodes:
            n.x = (n.x - xlow) / (xhigh - xlow)
            n.y = (n.y - ylow) / (yhigh - ylow)
