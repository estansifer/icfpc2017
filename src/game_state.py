import random
import numpy as np

#
# Gameboard consists of an undirected graph of edges.
#   Nodes are labelled by an integer SiteID.
#   Players are labelled by an integer, varying from 0 to n - 1 where n is the number of players.
#

class Node:
    # self.edges is a dictionary mapping the SiteID of neighboring sites to the instance of Edge
    # connecting them
    def __init__(self, nodeid):
        self.nodeid = nodeid
        self.ismine = False
        self.edges = {}

class Edge:
    def __init__(self, source, target, owner = -1):
        self.source = source
        self.target = target
        self.owner = owner


#
# Game -- holds the complete game state of the game at some point during play, including
#   any extra annotations that may have been added to help the solver.
#
# Game.from_json_setup(message)
#   Creates a new Game object using the message received from the server during setup.
# g.to_json_offline()
#   Returns an object suitable for serializing into json format which carries the complete
#   state of the game, for use in the offline mode.
# Game.from_json_offline(message)
#   Creates a Game object corresponding to the message received from the server, which had
#   been previously generated by the g.to_json_offline() function. In particular,
#       Game.from_json_offline(g.to_json_offline())
#   should yield a Game object with the same state as g.
#
# g.apply_moves(message)
#   Given a message received from the server describing moves made, update the game state.
# g.make_move(e) or g.make_pass()
#   Given an Edge instance which we should claim, return an appropriate message claiming
#   that edge to send to the server. The game state is not updated yet (it should be
#   updated by the response from the server).
#

class Game:
    # n -- number of players
    # me -- our player index, from 0 to n - 1 inclusive
    # self.nodes -- dictionary mapping SiteID to Node
    # self.edges -- list of all edges
    # self.mines -- list of SiteIDs of all Nodes which are mines
    def __init__(self, n, me):
        self.n = n
        self.me = me
        self.nodes = {}
        self.edges = []
        self.mines = []

    def from_json_setup(message):
        n = message['punters']
        me = message['punter']
        g = Game(n, me)
        m = message['map']

        for s in m['sites']:
            nodeid = s['id']
            node = Node(nodeid)
            g.nodes[nodeid] = node
            if 'x' in s:
                node.x = s['x']
                node.y = s['y']

        g.k = len(g.nodes)

        for r in m['rivers']:
            a = r['source']
            b = r['target']
            e = Edge(a, b)
            g.edges.append(e)
            g.nodes[a].edges[b] = e
            g.nodes[b].edges[a] = e

        for mine in m['mines']:
            g.nodes[mine].ismine = True
            g.mines.append(mine)

        return g

    def from_json_offline(message):
        n = message['punters']
        me = message['punter']
        g = Game(n, me)
        m = message['map']

        for s in m['sites']:
            nodeid = s['id']
            g.nodes[nodeid] = Node(nodeid)

        g.k = len(g.nodes)

        for r in m['rivers']:
            a = r['source']
            b = r['target']
            o = r['owner']
            e = Edge(a, b, o)
            g.edges.append(e)
            g.nodes[a].edges[b] = e
            g.nodes[b].edges[a] = e

        for mine in m['mines']:
            g.nodes[mine].ismine = True
            g.mines.append(mine)

        return g

    def to_json_offline(self):
        message = {}
        message['punters'] = self.n
        message['punter'] = self.me
        m = {'sites' : [], 'rivers' : [], 'mines' : []}
        message['map'] = m

        for node in self.nodes.values():
            m['sites'].append({'id' : node.nodeid})

        for edge in self.edges:
            m['rivers'].append({'source' : edge.source, 'target' : edge.target, 'owner' : edge.owner})

        for mine in self.mines:
            m['mines'].append(mine)

        return message

    def apply_moves(self, message):
        for m in message['move']:
            if 'pass' in m:
                continue
            if 'claim' in m:
                c = m['claim']
                e = self.nodes[c['source']].edges[c['target']]
                e.owner = c['punter']

    def make_move(self, e):
        message = {'claim' : {'punter' : self.me, 'source' : e.source, 'target' : e.target}}
        # Don't actually make move until it's been confirmed by the server.
        # e.owner = self.me
        return message

    def make_pass(self):
        return {'pass' : {'punter' : self.me}}

    def layout_initial(self):
        for node in self.nodes.values():
            node.x = random.random()
            node.y = random.random()

    def layout_relax(self, numsteps = 10):
        nodeids = []
        for n in self.nodes:
            nodeids.append(n)

        k = self.k

        x = np.zeros((k,))
        y = np.zeros((k,))
        connected = np.zeros((k, k), dtype = bool)
        diag = np.identity(k, dtype = bool)

        for i in range(k):
            x[i] = self.nodes[nodeids[i]].x
            y[i] = self.nodes[nodeids[i]].y
            for j in range(k):
                if nodeids[j] in self.nodes[nodeids[i]].edges:
                    connected[i, j] = True

        xlow = np.min(x)
        xhigh = np.max(x)
        ylow = np.min(y)
        yhigh = np.max(y)

        x = np.sqrt(k) * (x - xlow) / (xhigh - xlow)
        y = np.sqrt(k) * (y - ylow) / (yhigh - ylow)

        for i in range(numsteps):
            dx = np.zeros((k,))
            dy = np.zeros((k,))

            dd = (x[:, None] - x[None, :]) ** 2 + (y[:, None] - y[None, :]) ** 2
            dd[diag] = 1

            force_a = np.log(dd)
            # force_b = -1 / dd
            force_b = -1 / np.sqrt(dd)
            force_a[~connected] = 0
            force_b[connected] = 0
            force = force_a + force_b
            force[diag] = 0

            dx = np.sum(force * (x[None, :] - x[:, None]) / np.sqrt(dd), axis = 1)
            dy = np.sum(force * (y[None, :] - y[:, None]) / np.sqrt(dd), axis = 1)
            x += 0.1 * dx
            y += 0.1 * dy

        # Normalize positions to (0, 1)

        xlow = np.min(x)
        xhigh = np.max(x)
        ylow = np.min(y)
        yhigh = np.max(y)

        x = (x - xlow) / (xhigh - xlow)
        y = (y - ylow) / (yhigh - ylow)

        for i in range(k):
            self.nodes[nodeids[i]].x = x[i]
            self.nodes[nodeids[i]].y = y[i]

    def layout_normalize(self):
        xs = [self.nodes[nodeid].x for nodeid in self.nodes]
        ys = [self.nodes[nodeid].y for nodeid in self.nodes]

        xlow = min(xs)
        xhigh = max(xs)
        ylow = min(ys)
        yhigh = max(ys)

        for nodeid in self.nodes:
            n = self.nodes[nodeid]
            n.x = (n.x - xlow) / (xhigh - xlow)
            n.y = (n.y - ylow) / (yhigh - ylow)
